import re
import logging
import dataclasses
from pathlib import Path
from typing import NamedTuple
from functools import partial

import yt_dlp
from starlette.concurrency import run_in_threadpool
from yt_dlp.utils import YoutubeDLError

from core import settings
from common.enums import SourceType, EpisodeStatus
from common.exceptions import InvalidRequestError
from modules.auth.hasher import get_random_hash
from modules.podcast.models import EpisodeChapter
from modules.podcast.utils import episode_process_hook

logger = logging.getLogger(__name__)


class SourceMediaInfo(NamedTuple):
    """Structure of extended information about media source"""

    watch_url: str
    source_id: str
    description: str
    thumbnail_url: str
    title: str
    author: str
    length: int
    chapters: list[EpisodeChapter]


@dataclasses.dataclass
class SourceConfig:
    type: SourceType
    regexp: str | None = None
    regexp_playlist: str | None = None
    need_postprocessing: bool = False
    need_downloading: bool = True
    proxy_url: str | None = None


@dataclasses.dataclass
class SourceInfo:
    id: str
    type: SourceType
    url: str | None = None
    cookie_path: Path | None = None
    proxy_url: str | None = None


SOURCE_CFG_MAP = {
    SourceType.YOUTUBE: SourceConfig(
        type=SourceType.YOUTUBE,
        regexp=(
            r"^https://(?:www\.)?"
            r"[(?:youtube\.com)|(?:youtu\.be)]+[(/watch\?v=|\/)|(/live/)]+"
            r"(?P<source_id>[0-9a-zA-Z-_]{11})"
        ),
        regexp_playlist=(
            r"^https://(?:www\.)?youtube\.com/playlist\?list=(?P<source_id>[0-9a-zA-Z-_]+)"
        ),
        need_postprocessing=True,
        proxy_url=settings.PROXY_YOUTUBE,
    ),
    SourceType.YANDEX: SourceConfig(
        type=SourceType.YANDEX,
        regexp=r"https?://music\.yandex\.ru\/[a-z\/0-9]+\/track\/(?P<source_id>[0-9]+)",
        regexp_playlist=r"^https://music\.yandex\.ru/album/(?P<source_id>[0-9a-zA-Z-_]+)",
    ),
    SourceType.UPLOAD: SourceConfig(
        type=SourceType.UPLOAD,
        need_downloading=False,
    ),
}


def extract_source_info(source_url: str | None = None, playlist: bool = False) -> SourceInfo:
    """Extracts providers (source) info and finds source ID"""

    if not source_url:
        random_hash = get_random_hash(size=6)
        return SourceInfo(id=f"U-{random_hash}", type=SourceType.UPLOAD)

    for _, source_cfg in SOURCE_CFG_MAP.items():
        regexp = source_cfg.regexp if not playlist else source_cfg.regexp_playlist
        if match := (re.match(regexp, source_url) if source_cfg.regexp else None):
            if source_id := match.groupdict().get("source_id"):
                return SourceInfo(id=source_id, url=source_url, type=source_cfg.type)

            logger.error(
                "Couldn't extract source ID: Source link is not correct: %s | source_info: %s",
                source_url,
                source_cfg,
            )

    raise InvalidRequestError(f"Requested domain is not supported now {source_url}")


def download_process_hook(event: dict):
    """
    Allows handling processes of downloading episode's file.
    It is called by `yt_dlp.YoutubeDL`
    """
    total_bytes = event.get("total_bytes") or event.get("total_bytes_estimate", 0)
    episode_process_hook(
        status=EpisodeStatus.DL_EPISODE_DOWNLOADING,
        filename=event["filename"],
        total_bytes=total_bytes,
        processed_bytes=event.get("downloaded_bytes", total_bytes),
    )


async def download_audio(
    source_url: str,
    filename: str,
    cookie_path: Path | None,
    proxy_url: str | None = None,
) -> Path:
    """
    Download providers video and perform to audio (.mp3) file

    :param source_url: URL to providers video which are needed to download
    :param filename: autogenerated filename for episode
    :param cookie_path: path to cookie's file for accessing to protected source
    :param proxy_url: proxy DSN for downloading video (specified for each source's type_
    :return path to downloaded file
    """
    result_path = settings.TMP_AUDIO_PATH / filename
    params = {
        "format": "bestaudio/best",
        "outtmpl": str(result_path),
        "logger": logging.getLogger("yt_dlp.YoutubeDL"),
        "progress_hooks": [download_process_hook],
        "noprogress": True,
        "cookiefile": cookie_path,
    }
    if proxy_url:
        logger.info("YoutubeDL: Using proxy: %s", proxy_url)
        params["proxy"] = proxy_url

    with yt_dlp.YoutubeDL(params) as ydl:
        ydl.download([source_url])

    return result_path


async def get_source_media_info(source_info: SourceInfo) -> tuple[str, SourceMediaInfo | None]:
    """Allows extract info about providers video from Source (powered by yt_dlp)"""

    logger.info("Started fetching data for %s", source_info.url)
    params = {"logger": logger, "noplaylist": True, "cookiefile": source_info.cookie_path}
    if source_info.proxy_url:
        params["proxy"] = source_info.proxy_url
        logger.info("YoutubeDL: Using proxy: %s", source_info.proxy_url)

    try:
        with yt_dlp.YoutubeDL(params) as ydl:
            extract_info = partial(ydl.extract_info, source_info.url, download=False)
            source_details = await run_in_threadpool(extract_info)

    except YoutubeDLError as exc:
        logger.exception("ydl.extract_info failed: %s | Error: %r", source_info.url, exc)
        return str(exc), None

    youtube_info = SourceMediaInfo(
        title=source_details["title"],
        description=source_details.get("description") or source_details.get("title"),
        watch_url=source_details["webpage_url"],
        source_id=source_details["id"],
        thumbnail_url=source_details["thumbnail"],
        author=source_details.get("uploader") or source_details.get("artist"),
        length=source_details["duration"],
        chapters=chapters_processing(source_details.get("chapters")),
    )
    return "OK", youtube_info


def chapters_processing(input_chapters: list[dict] | None) -> list[EpisodeChapter]:
    """
    Allows to process input chapters data and adapt to internal chapter's format
    (for saving in DB and using in RSS generation)

    input:
        [{'end_time': 68.0, 'start_time': 15.0, 'title': 'Start application'}, ...]
    output:
        [EpisodeChapter(title='Start application', start='00:00:15', end='00:01:08'), ...]

    :param input_chapters: list of chapters data
    :return: list of chapters items
    """
    result_chapters: list[EpisodeChapter] = []
    if not input_chapters:
        return []

    for input_chapter in input_chapters:
        try:
            chapter = EpisodeChapter(
                title=input_chapter["title"],
                start=input_chapter["start_time"],
                end=input_chapter["end_time"],
            )

        except (KeyError, ValueError) as exc:
            logger.error("Couldn't prepare episode's chapter: %s | err: %r", input_chapter, exc)

        else:
            result_chapters.append(chapter)

    return result_chapters
